var documenterSearchIndex = {"docs":
[{"location":"reference/CheapStack/#CheapStack","page":"CheapStack","title":"CheapStack","text":"","category":"section"},{"location":"reference/CheapStack/#Moonshine.CheapStack","page":"CheapStack","title":"Moonshine.CheapStack","text":"struct CheapStack{T}\n\nSimple stack container.\n\nFunctionalities\n\nThe following operations are supported:\n\nisempty\nempty!\nfirst\nlength\npop!\npush!\n\nFor convenience, CheapStack implements the iteration interface.\n\nFields\n\nstore::UnsafeArrays.UnsafeArray{T, 1} where T\nptr::Base.RefValue{Int64}\n\n\n\n\n\n","category":"type"},{"location":"reference/CheapStack/#Moonshine.CheapStack-Tuple{UnsafeArrays.UnsafeArray}","page":"CheapStack","title":"Moonshine.CheapStack","text":"CheapStack(store)\n\n\nConstruct a CheapStack that uses an UnsafeArray as store.\n\n\n\n\n\n","category":"method"},{"location":"reference/Tree_Arg/#Tree-and-ARG","page":"Tree & ARG","title":"Tree & ARG","text":"","category":"section"},{"location":"reference/Tree_Arg/","page":"Tree & ARG","title":"Tree & ARG","text":"Pages = [\"Tree_Arg.md\"]\nDepth = 2:3","category":"page"},{"location":"reference/Tree_Arg/#Tree","page":"Tree & ARG","title":"Tree","text":"","category":"section"},{"location":"reference/Tree_Arg/#Moonshine.Tree","page":"Tree & ARG","title":"Moonshine.Tree","text":"struct Tree <: AbstractGenealogy\n\nCoalescent tree.\n\nSee also Arg.\n\nFields\n\ngraph::Graphs.SimpleGraphs.SimpleDiGraph{Int32}: Tree's topology\nlatitudes::Vector{Float64}: Vertices' latitudes\nsequences::Vector{Sequence}: Vertices' haplotypes\nsample::Sample: Associated Sample\nlogdensity::Base.RefValue{DoubleFloats.Double64}: Log-value of the associated pdf\n\nConstructors\n\ninfo: Info\nRandom constructor calls Sample's random constructor.\n\nwarning: Warning\nThese do not actually build the tree. For that, see build!(rng, tree).\n\nTree(graph, latitudes, sequences, sample, logdensity)\nTree(graph, latitudes, sequences, sample, logdensity)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:42.\n\nTree(sample)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:54.\n\nTree(rng, n, μ, ρ, Ne, sequence_length)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:66.\n\nArguments\n\nArguments are the same as for Sample.\n\n\n\n\n\n","category":"type"},{"location":"reference/Tree_Arg/#Moonshine.depth","page":"Tree & ARG","title":"Moonshine.depth","text":"depth(tree, v)\n\n\nDepth of a vertex.\n\n\n\n\n\n","category":"function"},{"location":"reference/Tree_Arg/#Arg","page":"Tree & ARG","title":"Arg","text":"","category":"section"},{"location":"reference/Tree_Arg/#Moonshine.Arg","page":"Tree & ARG","title":"Moonshine.Arg","text":"struct Arg <: AbstractGenealogy\n\nAncestral recombination graph.\n\nSee also Tree.\n\nFields\n\ngraph::Graphs.SimpleGraphs.SimpleDiGraph{Int32}: Graph's topology\nlatitudes::Vector{Float64}: Vertices' latitudes\nrecombination_mask::Vector{AncestralIntervals{Vector{IntervalSets.Interval{:closed, :open, Float64}}}}: ∩-mask for ancestral intervals\nmrca::Base.RefValue{Int32}: Arg's grand MRCA\nsequences::Vector{Sequence}: Vertices' haplotypes\nancestral_intervals::Dict{Graphs.SimpleGraphs.SimpleEdge{Int32}, AncestralIntervals{Vector{IntervalSets.Interval{:closed, :open, Float64}}}}: Edges' ancestral intervals\nsample::Sample: Associated Sample\nlogdensity::Base.RefValue{DoubleFloats.Double64}: Log-value of the associated pdf\n\nConstructors\n\ninfo: Info\nRandom constructor calls Sample's random constructor.\n\nwarning: Warning\nThese do not actually build the arg. For that, see build!(rng, arg).\n\nArg(\n    graph,\n    latitudes,\n    recombination_mask,\n    mrca,\n    sequences,\n    ancestral_intervals,\n    sample,\n    logdensity\n)\nArg(\n    graph,\n    latitudes,\n    recombination_mask,\n    mrca,\n    sequences,\n    ancestral_intervals,\n    sample,\n    logdensity\n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:43.\n\nArg(tree)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:61.\n\nArg(rng, n, μ, ρ, Ne, sequence_length)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:77.\n\nArguments\n\ntree: coalescent Tree\nother arguments are identical to Sample\n\n\n\n\n\n","category":"type"},{"location":"reference/Tree_Arg/#Moonshine.breakpoints","page":"Tree & ARG","title":"Moonshine.breakpoints","text":"breakpoints(arg)\n\n\nRecombination events' positions\n\n\n\n\n\n","category":"function"},{"location":"reference/Tree_Arg/#Moonshine.plot_breakpoints","page":"Tree & ARG","title":"Moonshine.plot_breakpoints","text":"plot_breakpoints(arg; nbins, height, kwargs...)\n\n\nHeatmap of recombination events' positions.\n\nSee also breakpoints\n\nKeywords\n\nnbins (clamp(nrecombinations(arg) ÷ 100, 1, 69)): number of bins. Its default maximum value of 69 produces a nice 80 columns wide plot.\nheight (7): height of the plot.\nkwargs...: additional keywords arguments are passed directly to UnicodePlots.histogram.\n\n\n\n\n\n","category":"function"},{"location":"reference/Tree_Arg/#Moonshine.otherdad","page":"Tree & ARG","title":"Moonshine.otherdad","text":"otherdad(arg, s, d)\notherdad(arg, e)\n\nReturn the parent of d that is not s for a recombination vertex d. If d is not a recombination vertex, returns s. Can also take an edge as argument.\n\nMethods\n\notherdad(arg, s, d)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:366.\n\notherdad(arg, e)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:377.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/Tree_Arg/#Moonshine.rlat_min","page":"Tree & ARG","title":"Moonshine.rlat_min","text":"rlat_min(arg, e, nextidx)\n\nCompute the minimum latitude for a recombination event rooted on e.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/Tree_Arg/#Moonshine.recombination_mask","page":"Tree & ARG","title":"Moonshine.recombination_mask","text":"recombination_mask(arg, e)\n\n\nIntervals of the partition of [0, ∞) induced by a recombination event for\nwhich an edge is ancestral.\n\n\n\n\n\n","category":"function"},{"location":"reference/Tree_Arg/#Moonshine.recombine!","page":"Tree & ARG","title":"Moonshine.recombine!","text":"recombine!(arg, redge, cedge, breakpoint, rlat, clat[, stack]; buffer = default_buffer())\n\nAdd a recombination event to an ARG.\n\nMethods\n\nrecombine!(\n    arg,\n    redge,\n    cedge,\n    breakpoint,\n    rlat,\n    clat,\n    stack;\n    buffer\n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Recombination.jl:86.\n\nrecombine!(\n    arg,\n    redge,\n    cedge,\n    breakpoint,\n    rlat,\n    clat;\n    buffer\n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Recombination.jl:149.\n\n\n\n\n\n","category":"function"},{"location":"reference/Tree_Arg/#MMN","page":"Tree & ARG","title":"MMN","text":"","category":"section"},{"location":"reference/Tree_Arg/#Moonshine.next_inconsistent_idx","page":"Tree & ARG","title":"Moonshine.next_inconsistent_idx","text":"next_inconsistent_idx(\n    arg,\n    idx,\n    stack;\n    mutations_edges,\n    buffer\n)\n\n\nIndex of the next inconsistent marker, that is the next which mutates more than once in a given ancestral recombination graph.\n\nstack must be of type CheapStack{Edge{VertexType}} (see CheapStack).\n\n\n\n\n\n","category":"function"},{"location":"reference/Tree_Arg/#Common","page":"Tree & ARG","title":"Common","text":"","category":"section"},{"location":"reference/Tree_Arg/#Moonshine.build!","page":"Tree & ARG","title":"Moonshine.build!","text":"build!(rng, genealogy; kwargs...)\n\nBuild a genealogy.\n\nMethods\n\nbuild!(rng, arg; winwidth, buffer, noprogress)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Recombination.jl:663.\n\nbuild!(rng, tree; Dist, bias0, threshold_prop)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:243.\n\nArguments\n\nwinwidth (∞): width of the window of positions to consider\nnoprogress (false): hide progress bar\nDist (Hamming{Int}()): distance used to compute coalescence probabilities\nbias0 (10): distance multiplier: higher values favour coalescence events between similar haplotypes\nthreshold_prop (1): proportion of events to consider when sampling\n\n\n\n\n\n","category":"function"},{"location":"reference/AncestralIntervals/#Ancestral-Intervals","page":"Ancestral Intervals","title":"Ancestral Intervals","text":"","category":"section"},{"location":"reference/AncestralIntervals/#Moonshine.Ω","page":"Ancestral Intervals","title":"Moonshine.Ω","text":"const Ω = Interval{:closed, :open, Float64}\n\nRight semi-open interval.\n\nSee also AI, AIs and AncestralIntervals.\n\n\n\n\n\n","category":"type"},{"location":"reference/AncestralIntervals/#Moonshine.AncestralIntervals","page":"Ancestral Intervals","title":"Moonshine.AncestralIntervals","text":"struct AncestralIntervals{T<:(AbstractVector{<:IntervalSets.AbstractInterval})} <: AbstractVector{IntervalSets.AbstractInterval}\n\nCollection of intervals.\n\nMeant to represent the set of intervals an edge/vertex is ancestral for. You might want to use the convenient shorthand AIs instead.\n\nImplements the iteration interface and the array interface.\n\nSee also AI and Ω.\n\nFields\n\ndata::AbstractVector{<:IntervalSets.AbstractInterval}\n\nConstructors\n\nAncestralIntervals(data; simplify)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/AncestralIntervals.jl:78.\n\nArguments\n\nIf simplify = true, intervals contained in data are simplified: see simplify! for details.\n\nwarning: Warning\nMany methods assume AIs to be simplified. You might want to disable simplification to optimize a sequence of operation, but you should probably simplify the final result.\n\n\n\n\n\n","category":"type"},{"location":"reference/AncestralIntervals/#Moonshine.AIs","page":"Ancestral Intervals","title":"Moonshine.AIs","text":"const AIs = AncestralIntervals\n\nAlias for AncestralIntervals.\n\nSee also AI and Ω.\n\n\n\n\n\n","category":"type"},{"location":"reference/AncestralIntervals/#Moonshine.simplify!","page":"Ancestral Intervals","title":"Moonshine.simplify!","text":"simplify!(ωs)\n\n\nSimplify an AIs.\n\nTwo operations are performed:\n\nconnected intervals are merged together (see isdisconnected);\nintervals are sorted by left endpoint.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/AncestralIntervals/#Moonshine.isdisconnected","page":"Ancestral Intervals","title":"Moonshine.isdisconnected","text":"isdisconnected(A, B)\n\n\nTrue if intervals are disconnected, that is their intersection is empty and they do not share an endpoint.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/AncestralIntervals/#Moonshine.closure","page":"Ancestral Intervals","title":"Moonshine.closure","text":"closure(x)\n\nMathematical closure of x\n\nMethods\n\nclosure(ωs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/AncestralIntervals.jl:308.\n\n\n\n\n\n","category":"function"},{"location":"reference/globals/#Global-Values","page":"Global Values","title":"Global Values","text":"","category":"section"},{"location":"reference/globals/#Moonshine.VertexType","page":"Global Values","title":"Moonshine.VertexType","text":"const VertexType = Int32\n\nType of the vertices. Any genealogy that is an instance of AbstractGenealogy should be constructed so that graph(genealogy) is an instance of AbstractGraphs{VertexType} (see Graphs.AbstractGraph.)\n\n–Internal–\n\n\n\n\n\n","category":"type"},{"location":"reference/globals/#Moonshine.AI","page":"Global Values","title":"Moonshine.AI","text":"const AI = AbstractInterval\n\nAbstract types for intervals from IntervalSets.\n\nSee also IntervalSets.AbstractInterval and Ω.\n\n–Internal–\n\n\n\n\n\n","category":"type"},{"location":"reference/globals/#Moonshine.mmn_chunksize","page":"Global Values","title":"Moonshine.mmn_chunksize","text":"const mmn_chunksize = 1\n\nSize (in bytes) of a chunk of markers in next_inconsistent_idx.\n\n–Internal–\n\n\n\n\n\n","category":"constant"},{"location":"reference/globals/#Moonshine.mmn_chunktype","page":"Global Values","title":"Moonshine.mmn_chunktype","text":"const mmn_chunktype = (eval ∘ Symbol)(\"UInt\" * string(8mmn_chunksize))\n\nType of a chunk of markers in next_inconsistent_idx.\n\n–Internal–\n\n\n\n\n\n","category":"type"},{"location":"reference/globals/#Moonshine.simd_vecsize","page":"Global Values","title":"Moonshine.simd_vecsize","text":"const simd_vecsize = simdbytes()\n\nSize (in bytes) of a SIMD registry on host machine.\n\n–Internal–\n\n\n\n\n\n","category":"constant"},{"location":"reference/globals/#Moonshine.simd_chunksize","page":"Global Values","title":"Moonshine.simd_chunksize","text":"const simd_chunksize = simd_vecsize ÷ 8\n\nNumber of chunks of markers that fit in a SIMD registry.\n\n–Internal–\n\n\n\n\n\n","category":"constant"},{"location":"reference/globals/#Moonshine.default_colormap","page":"Global Values","title":"Moonshine.default_colormap","text":"default_colormap = :Paired_3\n\nColor map used by UnicodePlots.jl. See ColorSchemes.jl.\n\n\n\n\n\n","category":"constant"},{"location":"design/#Naming-Conventions","page":"Design & conventions","title":"Naming Conventions","text":"","category":"section"},{"location":"design/#Arguments","page":"Design & conventions","title":"Arguments","text":"","category":"section"},{"location":"design/#Genealogies","page":"Design & conventions","title":"Genealogies","text":"","category":"section"},{"location":"design/","page":"Design & conventions","title":"Design & conventions","text":"genealogy: AbstractGenealogy\ntree: coalescent tree (usually of type Tree)\narg: ancestral recombination graph (usually of type Arg)\nKeep in mind that by definition, a coalescent tree is an ancestral recombination graph.","category":"page"},{"location":"design/#Graphs","page":"Design & conventions","title":"Graphs","text":"","category":"section"},{"location":"design/","page":"Design & conventions","title":"Design & conventions","text":"v: vertex (usually of type VertexType)\nvs: vertices\ne: edge (usually of type Edge{VertexType}, see Graphs.Edge)\nes: edges","category":"page"},{"location":"design/#Sequences","page":"Design & conventions","title":"Sequences","text":"","category":"section"},{"location":"design/","page":"Design & conventions","title":"Design & conventions","text":"h: haplotype (usually of type Sequence, sometimes a BitVector or Vector{UInt}\nidx: index or indices of markers, i.e. element or subset or the range 1:n where n is the number of markers\npos: position or positions of markers, i.e. element or subset of mathbb R","category":"page"},{"location":"design/#Intervals","page":"Design & conventions","title":"Intervals","text":"","category":"section"},{"location":"design/","page":"Design & conventions","title":"Design & conventions","text":"ω: right semi-open interval (usually of type Ω)\nωs: ω or collection of ωs (usually of type AIs)","category":"page"},{"location":"design/#Keyword-Arguments","page":"Design & conventions","title":"Keyword Arguments","text":"","category":"section"},{"location":"design/","page":"Design & conventions","title":"Design & conventions","text":"buffer: SlabBuffer or AllocBuffer from Bumper.jl","category":"page"},{"location":"design/#Constructors","page":"Design & conventions","title":"Constructors","text":"","category":"section"},{"location":"design/","page":"Design & conventions","title":"Design & conventions","text":"For a type T:","category":"page"},{"location":"design/","page":"Design & conventions","title":"Design & conventions","text":"T() is the empty constructor\nT(rng, ...) is a random constructor","category":"page"},{"location":"reference/Sequence/#Sequence","page":"Sequence","title":"Sequence","text":"","category":"section"},{"location":"reference/Sequence/","page":"Sequence","title":"Sequence","text":"Pages = [\"Sequence.md\"]\nDepth = 2","category":"page"},{"location":"reference/Sequence/#Sequences","page":"Sequence","title":"Sequences","text":"","category":"section"},{"location":"reference/Sequence/#Moonshine.Sequence","page":"Sequence","title":"Moonshine.Sequence","text":"struct Sequence\n\nSequence of biallelic genetic markers (haplotype).\n\nImplement the iteration interface as well as standard bitwise operations.\n\ninfo: Info\nRandom constructors sample marker's states via Random.bitrand.\n\nFields\n\ndata::BitVector\n\nConstructors\n\nSequence(data)\nSequence(data)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:48.\n\nSequence()\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:197.\n\nSequence(undef, n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:199.\n\nSequence(rng, n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:201.\n\nSequence(rng, minlength, maxlength)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:203.\n\nwhere:\n\nn: number of markers\nrng: random number generator\nminLength, maxLength: bounds for sequence length\n\n\n\n\n\n","category":"type"},{"location":"reference/Sequence/#Moonshine.cheap_hash","page":"Sequence","title":"Moonshine.cheap_hash","text":"cheap_hash\n\nSimple (and fast) hash function.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/Sequence/#Moonshine.blocksize","page":"Sequence","title":"Moonshine.blocksize","text":"blocksize(::Type{Sequence})\nblocksize(::Sequence)\n\nSize (in bits) of the blocks (chunks) of a sequence.\n\nMethods\n\nblocksize(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:127.\n\nblocksize(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:129.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/Sequence/#Moonshine.idxinchunk","page":"Sequence","title":"Moonshine.idxinchunk","text":"idxinchunk(n, x)\nidxinchunk(::Type{Sequence}, x)\nidxinchunk(::Sequence, x)\n\nIndex of marker x in its associated chunk.\n\nSee also chunkidx.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/Sequence/#Moonshine.chunkidx","page":"Sequence","title":"Moonshine.chunkidx","text":"chunkidx(n, x)\nchunkidx(::Type{Sequence}, x)\nchunkidx(::Sequence, x)\n\nIndex of the chunk associated with marker x.\n\nSee also idxinchunk.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/Sequence/#Moonshine.wipe!","page":"Sequence","title":"Moonshine.wipe!","text":"wipe!(h)\n\n\nSet all markers to wild state (0).\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/Sequence/#Moonshine.plot_sequence","page":"Sequence","title":"Moonshine.plot_sequence","text":"plot_sequence(h; nbins, height, kwargs...)\n\n\nUnicode-graphic representation of an haplotype.\n\nArguments\n\nnbins (clamp(length(h), 1, 69)): number of bins\ǹheight (7): number of rows\nkwargs: arguments passed directly to UnicodePlots.heatmap\n\n\n\n\n\n","category":"function"},{"location":"reference/Sequence/#Distances","page":"Sequence","title":"Distances","text":"","category":"section"},{"location":"reference/Sequence/#Moonshine.Distance","page":"Sequence","title":"Moonshine.Distance","text":"abstract type Distance{T}\n\nDistance between two Sequences.\n\nImplementation\n\nThe only required method for a distance D<:Distance to be usable for tree contruction is\n\ndistance(::D{T}, ::Sequence, ::Sequence) where T\n\nIt is also useful to implement a default constructor. For example, if D is a discrete distance,\n\nD() = D{Int}()\n\n\n\n\n\n","category":"type"},{"location":"reference/Sequence/#Moonshine.Hamming","page":"Sequence","title":"Moonshine.Hamming","text":"struct Hamming{T} <: Distance{T}\n\nHamming distance.\n\n\n\n\n\n","category":"type"},{"location":"reference/Sequence/#Moonshine.LeftM","page":"Sequence","title":"Moonshine.LeftM","text":"struct LeftM{T} <: Distance{T}\n\nLeft marker distance.\n\nThis is only the discrete metric for the leftmost marker. Technically not a metric for haplotypes, but widely used.\n\n\n\n\n\n","category":"type"},{"location":"reference/Sequence/#Moonshine.distance","page":"Sequence","title":"Moonshine.distance","text":"distance(Dist, h1, h2)\ndistance(Dist, H)\n\nCompute distances between sequences.\n\nMethods\n\ndistance(Dist, H)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:284.\n\ndistance(_, h1, h2)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:308.\n\ndistance(_, h1, h2)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sequence.jl:333.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#AbstractGenealogy","page":"AbstractGenealogy","title":"AbstractGenealogy","text":"","category":"section"},{"location":"reference/AbstractGenealogy/","page":"AbstractGenealogy","title":"AbstractGenealogy","text":"Pages = [\"AbstractGenealogy.md\"]\nDepth = 2:4","category":"page"},{"location":"reference/AbstractGenealogy/#Types","page":"AbstractGenealogy","title":"Types","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.AbstractGenealogy","page":"AbstractGenealogy","title":"Moonshine.AbstractGenealogy","text":"abstract type AbstractGenealogy <: Graphs.SimpleGraphs.AbstractSimpleGraph{Int32}\n\nAbstract type for genealogies.\n\nImplements the Graphs.jl interface so that subtypes implementing the AbstractGenealogy interface can additionally be treated as regular graphs.\n\nTree & Arg are subtypes that implement the AbstractGenealogy interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/AbstractGenealogy/#Moonshine.EdgesInterval","page":"AbstractGenealogy","title":"Moonshine.EdgesInterval","text":"struct EdgesInterval{T, I, E}\n\nFlexible edge iterators that supports various constraints.\n\nPossible constraints are any combination of the following:\n\nAn interval of genetic positions. Any non-ancestral edge is ignored.\nA minimum latitude. Any edge under that latitude is ignored. An edge e is considered under a latitude l if latitude(genealogy, dst(e)) < l.\nA set of predicates. If any of the predicates evaluate to true for a given edge, that edge is ignored.\n\nDo not construct directly, use edges_interval instead.\n\nFields\n\ngenealogy::Any: Genealogy to iterate over\nωs::Any: Interval to consider\nbuffer::CheapStack: Edges buffer\nvisited::UnsafeArrays.UnsafeArray{Bool, 1}: True is associated recombination vertex has been visited previously\nmin_latitude::Float64: Only consider edges located above this latitude\nblock_predicates::Array{FunctionWrappers.FunctionWrapper{Bool, Tuple{E}}, 1} where E: Edges for which one of the predicates is true are blocked\n\nConstructors\n\nEdgesInterval(\n    genealogy,\n    ωs,\n    buffer,\n    visited,\n    min_latitude,\n    block_predicates\n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1106.\n\nEdgesInterval(genealogy, ωs, stack, visited)\nEdgesInterval(genealogy, ωs, stack, visited, root)\nEdgesInterval(\n    genealogy,\n    ωs,\n    stack,\n    visited,\n    root,\n    min_latitude\n)\nEdgesInterval(\n    genealogy,\n    ωs,\n    stack,\n    visited,\n    root,\n    min_latitude,\n    block_predicates\n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1120.\n\nEdgesInterval(genealogy, ωs, store, visited)\nEdgesInterval(genealogy, ωs, store, visited, root)\nEdgesInterval(\n    genealogy,\n    ωs,\n    store,\n    visited,\n    root,\n    min_latitude,\n    block_predicates\n)\nEdgesInterval(\n    genealogy,\n    ωs,\n    store,\n    visited,\n    root,\n    min_latitude\n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1134.\n\n–Internal–\n\n\n\n\n\n","category":"type"},{"location":"reference/AbstractGenealogy/#Functions","page":"AbstractGenealogy","title":"Functions","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Interface","page":"AbstractGenealogy","title":"Interface","text":"","category":"section"},{"location":"reference/AbstractGenealogy/","page":"AbstractGenealogy","title":"AbstractGenealogy","text":"AbstractGenealogy interface. Subtypes must implement every method unless otherwise specified.","category":"page"},{"location":"reference/AbstractGenealogy/#General","page":"AbstractGenealogy","title":"General","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.dens","page":"AbstractGenealogy","title":"Moonshine.dens","text":"dens(genealogy; logscale = false)\n\nLikelihood of a genealogy.\n\nImplementation\n\nOnly mandatory if copulas are to be fitted on the genealogy.\n\nMethods\n\ndens(arg; logscale)\ndens(tree; logscale)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/genealogy_common.jl:48.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.describe","page":"AbstractGenealogy","title":"Moonshine.describe","text":"describe(genealogy, long = true)\n\nReturn a string containing a long or short description of a genealogy. Used internally by pretty printing functions.\n\nMethods\n\ndescribe()\ndescribe(, long)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:89.\n\ndescribe()\ndescribe(, long)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:77.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.graph","page":"AbstractGenealogy","title":"Moonshine.graph","text":"graph(genealogy)\n\nReturn the underlying graph of a genealogy.\n\nMethods\n\ngraph(arg)\ngraph(tree)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/genealogy_common.jl:31.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Vertices/Edges","page":"AbstractGenealogy","title":"Vertices/Edges","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.latitudes","page":"AbstractGenealogy","title":"Moonshine.latitudes","text":"latitudes(genealogy[, vs])\n\nReturn the latitudes of (a subset of) the internal vertices of a genealogy.\n\nSee also latitude to get the latitude of a single vertex.\n\nImplementation\n\nA default implementation for latitudes(::AbstractGenealogy, ::Any) is available; only latitudes(::T) is required.\n\nMethods\n\nlatitudes(genealogy, vs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:80.\n\nlatitudes(arg)\nlatitudes(tree)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/genealogy_common.jl:31.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.latitude","page":"AbstractGenealogy","title":"Moonshine.latitude","text":"latitude(genealogy, v)\n\nLatitude of a vertex.\n\nSee also latitudes to get the latitudes of internal vertices stored in a genealogy.\n\nMethods\n\nlatitude(arg, v)\nlatitude(tree, v)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/genealogy_common.jl:42.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.leaves","page":"AbstractGenealogy","title":"Moonshine.leaves","text":"leaves(genealogy)\n\n\nReturn an interable containing the leaves of a genealogy.\n\nSee also ivertices for internal vertices and nleaves for the number of leaves.\n\nImplementation\n\nDefault implementations assume that the first nleaves(genealogy) vertices are the leaves of the genealogy. If this is the case for your type, you do not need to implement this method.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.ivertices","page":"AbstractGenealogy","title":"Moonshine.ivertices","text":"ivertices(genealogy)\n\n\nReturn an interable containing the internal vertices of a genealogy.\n\nSee also leaves for leaves and nivertices for the number of leaves and internal vertices.\n\nImplementation\n\nDefault implementations assume that the first nleaves(genealogy) vertices are the leaves of the genealogy. If this is the case for your type, you do not need to implement this method.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.maxdads","page":"AbstractGenealogy","title":"Moonshine.maxdads","text":"maxdads(genealogy)\n\nMaximum possible number of parents for a vertex. See also maxchildren.\n\nImplementation\n\nMust be a generated function.\n\nMethods\n\nmaxdads(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:111.\n\nmaxdads(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:351.\n\nmaxdads(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:83.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.maxchildren","page":"AbstractGenealogy","title":"Moonshine.maxchildren","text":"maxchildren(genealogy)\n\nMaximum possible number of children for a vertex. See also maxdads.\n\nImplementation\n\nMust be a generated function.\n\nMethods\n\nmaxchildren(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:113.\n\nmaxchildren(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:351.\n\nmaxchildren(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:85.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Sequences","page":"AbstractGenealogy","title":"Sequences","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.positions","page":"AbstractGenealogy","title":"Moonshine.positions","text":"positions(genealogy)\n\nPositions of the markers.\n\nMethods\n\npositions(sample)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:163.\n\npositions(arg)\npositions(tree)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/genealogy_common.jl:35.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.sequences","page":"AbstractGenealogy","title":"Moonshine.sequences","text":"sequences(genealogy[, e])\nsequences(genealogy[, vs])\n\nSequences of a genealogy. If an edge is specified, return the sequences associated with the vertices incident to that edge. If an iterable of vertices is specified, return the sequences associated with these vertices.\n\nSee also sequence to get the sequence associated with a vertex.\n\nImplementation\n\nCustom types only need to implement sequences(::T).\n\nMethods\n\nsequences(genealogy, vs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:147.\n\nsequences(genealogy, e)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:149.\n\nsequences(arg)\nsequences(tree)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/genealogy_common.jl:31.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Ancestrality","page":"AbstractGenealogy","title":"Ancestrality","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.ancestral_intervals","page":"AbstractGenealogy","title":"Moonshine.ancestral_intervals","text":"ancestral_intervals(genealogy, x)\n\nInterval for which x is ancestral. Default implementation assumes that anything is ancestral for [0, ∞).\n\nSee also ancestral_intervals! for a non-allocating alternative.\n\nMethods\n\nancestral_intervals(arg, e)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:191.\n\nancestral_intervals(arg, v)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:204.\n\nancestral_intervals(genealogy, x)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:204.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.ancestral_intervals!","page":"AbstractGenealogy","title":"Moonshine.ancestral_intervals!","text":"ancestral_intervals!(ωs, genealogy, x)\n\nInterval for which x is ancestral. Default implementation assumes that anything is ancestral for [0, ∞).\n\nSee also ancestral_intervals.\n\nMethods\n\nancestral_intervals!(ωs, arg, e; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:183.\n\nancestral_intervals!(ωs, arg, v; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:193.\n\nancestral_intervals!(ωs, _, _)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:221.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.mrca","page":"AbstractGenealogy","title":"Moonshine.mrca","text":"mrca(genealogy[, vs = leaves(genealogy), ωs = Ω(0, ∞)])\n\nMost recent common ancestor of a set of vertices.\n\nSee also tmrca for the time to the most recent common ancestor.\n\nMethods\n\nmrca(arg)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:107.\n\nmrca(arg, ωs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:109.\n\nmrca(tree)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:79.\n\nmrca(tree, _)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:81.\n\nmrca(tree, vs, x; buffer)\nmrca(arg, vs, x; buffer)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/genealogy_common.jl:77.\n\nmrca(tree, vs)\nmrca(arg, vs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/genealogy_common.jl:101.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Recombinations","page":"AbstractGenealogy","title":"Recombinations","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.recombinations","page":"AbstractGenealogy","title":"Moonshine.recombinations","text":"recombinations(genealogy)\n\nIterator over the recombination vertices of a genealogy.\n\nImplementation\n\nDefault implementation returns an empty iterator.\n\nMethods\n\nrecombinations(arg)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:95.\n\nrecombinations(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:258.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.isrecombination","page":"AbstractGenealogy","title":"Moonshine.isrecombination","text":"isrecombination(genealogy, v)\n\nReturns true if vertex v is a recombination for genealogy.\n\nDefault implementation always returns false.\n\nMethods\n\nisrecombination(_, v, n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:91.\n\nisrecombination(arg, v)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:93.\n\nisrecombination(_, _)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:273.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.nrecombinations","page":"AbstractGenealogy","title":"Moonshine.nrecombinations","text":"nrecombinations(genealogy)\n\nNumber of recombinations.\n\nImplementation\n\nDefault implementation returns 0.\n\nMethods\n\nnrecombinations(arg)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:105.\n\nnrecombinations(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:242.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Plotting","page":"AbstractGenealogy","title":"Plotting","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.plot_layout","page":"AbstractGenealogy","title":"Moonshine.plot_layout","text":"plot_layout(genealogy)\n\nLayout function for genealogy plotting.\n\nImplementation\n\nDefaults to Spring().\n\nMethods\n\nplot_layout(arg)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:167.\n\nplot_layout(_)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:290.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#General-2","page":"AbstractGenealogy","title":"General","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Vertices/Edges-2","page":"AbstractGenealogy","title":"Vertices/Edges","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.nleaves","page":"AbstractGenealogy","title":"Moonshine.nleaves","text":"nleaves(genealogy)\n\nNumber of leaves in a genealogy.\n\nSee also leaves for an iterable over leaves and nivertices for an internal vertices counterpart.\n\nMethods\n\nnleaves(arg)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:87.\n\nnleaves(genealogy)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:568.\n\nnleaves(tree)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Tree.jl:75.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.nivertices","page":"AbstractGenealogy","title":"Moonshine.nivertices","text":"nivertices(genealogy)\n\n\nNumber of internal vertices in a genealogy.\n\nSee also ivertices for an iterable over internal vertices and nleaves for a leaves counterpart.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.isleaf","page":"AbstractGenealogy","title":"Moonshine.isleaf","text":"isleaf(genealogy, v)\n\nTrue if v is a leaf.\n\nSee also isivertex, isroot.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.isroot","page":"AbstractGenealogy","title":"Moonshine.isroot","text":"isroot(genealogy, v)\n\nTrue if v is the root.\n\nSee also isleaf, isivertex.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.isivertex","page":"AbstractGenealogy","title":"Moonshine.isivertex","text":"isivertex(genealogy, v)\n\n\nTrue if v is an internal vertex.\n\nSee also isleaf, isroot.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.branchlength","page":"AbstractGenealogy","title":"Moonshine.branchlength","text":"branchlength(genealogy)\nbranchlength(genealogy, ωs)\nbranchlength(genealogy, e)\n\nTotal branch length of a genealogy. If an interval is specified, returns the branch length of the associated marginal genealogy. If an edge is specified, returns the length of that edge.\n\nMethods\n\nbranchlength(genealogy, e)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:620.\n\nbranchlength(genealogy)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:623.\n\nbranchlength(genealogy, ωs; buffer)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:625.\n\nbranchlength(genealogy, s, d)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1078.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.edges_interval","page":"AbstractGenealogy","title":"Moonshine.edges_interval","text":"edges_interval(genealogy, ωs)\nedges_interval(genealogy, ωs, buffer, visited, root = mrca(genealogy), min_latitude = zero(Float64), block_predicates = [])\n\nIterage over a genealogy's edges via EdgesInterval.\n\nbuffer can be either a CheapStack or an UnsafeArray that will be used as buffer for a newly constructed CheapStack.\n\nMethods\n\nedges_interval(\n    genealogy,\n    ωs,\n    buffer,\n    visited,\n    root,\n    min_latitude;\n    block_predicates\n)\nedges_interval(genealogy, ωs, buffer, visited, root; ...)\nedges_interval(genealogy, ωs, buffer, visited; ...)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1195.\n\nedges_interval(genealogy, ωs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1200.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.edgesmap","page":"AbstractGenealogy","title":"Moonshine.edgesmap","text":"edgesmap(genealogy)\n\n\nReturn a Dict that maps every edge of a genealogy to an integer in 1:ne(genealogy).\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.nlive!","page":"AbstractGenealogy","title":"Moonshine.nlive!","text":"nlive!(counts, genealogy, lats, ωs,[ root] stack; block_predicates = [], buffer = default_buffer())\n\nNumber of live edges in a (marginal) genealogy at a given latitude.\n\nCounts are stored in counts, which is initially filled with zeros.\n\nGraph traversal is performed downward from root. It can be either a single vertex or a vector of vertices. If it is a vector, the counts from the traversal from each root are added together.\n\nblock_predicate and stack are passed directly to edges_interval.\n\nMethods\n\nnlive!(\n    counts,\n    genealogy,\n    lats,\n    ωs,\n    root,\n    stack;\n    block_predicates,\n    buffer\n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1267.\n\nnlive!(\n    counts,\n    genealogy,\n    lats,\n    ωs,\n    root,\n    stack;\n    block_predicates,\n    buffer\n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1285.\n\nnlive!(\n    counts,\n    genealogy,\n    lats,\n    ωs,\n    stack;\n    block_predicates,\n    buffer\n)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1300.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.ismutation_edge","page":"AbstractGenealogy","title":"Moonshine.ismutation_edge","text":"ismutation_edge(genealogy, e, idx)\n\n\nDetermines if an edge is a mutation edge for a given marker.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Sequences-2","page":"AbstractGenealogy","title":"Sequences","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.sequence","page":"AbstractGenealogy","title":"Moonshine.sequence","text":"sequence(genealogy, v)\n\n\nSequence of a genealogy associated with a vertex.\n\nSee also sequences to get all the sequences of a genealogy.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.idxtopos","page":"AbstractGenealogy","title":"Moonshine.idxtopos","text":"idxtopos(genealogy, idx)\n\nReturn the position of the marker given its index.\n\nMethods\n\nidxtopos(genealogy, idx)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:382.\n\nidxtopos(sample, idx)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:169.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.postoidx","page":"AbstractGenealogy","title":"Moonshine.postoidx","text":"postoidx(genealogy, pos)\n\nReturn the largest marker's index that is at a position lesser than the one given.\n\nMethods\n\npostoidx(genealogy, pos)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:382.\n\npostoidx(sample, pos)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:177.\n\npostoidx(sample, ω)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:220.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.nmarkers","page":"AbstractGenealogy","title":"Moonshine.nmarkers","text":"nmarkers(genealogy[, ωs])\n\nNumber of markers in the sequences of a genealogy. If an interval ωs is specified, returns the number of markers contained in that interval.\n\nMethods\n\nnmarkers(genealogy, ωs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:603.\n\nnmarkers(sample)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:165.\n\nnmarkers(sample, ω)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:167.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.nmutations","page":"AbstractGenealogy","title":"Moonshine.nmutations","text":"nmutations(genealogy[, e])\n\nNumber of mutation on a genealogy. If an edge is specified, return the number of mutations on that edge.\n\nSee also nmutations! for a non-allocating alternative.\n\nMethods\n\nnmutations(genealogy)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1065.\n\nnmutations(genealogy, e)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1071.\n\nnmutations(genealogy, s, d)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:1078.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.nmutations!","page":"AbstractGenealogy","title":"Moonshine.nmutations!","text":"nmutations!(mask, genealogy, e)\n\n\nNumber of mutation on a genealogy. If an edge is specified, return the number of mutations on that edge.\n\nSee also nmutations.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Ancestrality-2","page":"AbstractGenealogy","title":"Ancestrality","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.dad","page":"AbstractGenealogy","title":"Moonshine.dad","text":"dad(genealogy, v)\n\nReturn the parent of a vertex or 0 if none. It only makes sense to use this method if you know v has a single parent. Otherwise use dads.\n\nSee also child, descendants, ancestors and ̀siblings.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.dads","page":"AbstractGenealogy","title":"Moonshine.dads","text":"dads(genealogy, v[, ωs])\n\nParents of a vertex, optionally restricted to a marginal genealogy. If you know in advance that v has a single dad, use ̀̀dad instead.\n\nThe following rules are used to decide if an edge e is ancestral:\n\nIf ωs is a number, the ancestral interval of e must cover ωs.\nIf ωs is an Ω or a set of Ωs, the intersection of the ancestral interval of e with ωs must be non-empty.\n\ndanger: Danger\nReturn a reference to the underlying adjacency lists. No touchy!\n\nSee also child, children, sibling, siblings, descendants and ancestors.\n\nMethods\n\ndads(arg, v, ωs)\ndads(arg, v, ωs)\ndads(arg, v, ωs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:123.\n\ndads(genealogy, v)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:740.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.child","page":"AbstractGenealogy","title":"Moonshine.child","text":"child(genealogy, v)\n\nReturn the child of a vertex or 0 if none. It only makes sense to use this method if you know v has a single child. Otherwise use children.\n\nSee also dad, ancestors, descendants and ̀siblings.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.children","page":"AbstractGenealogy","title":"Moonshine.children","text":"children(genealogy, v[, ωs])\n\nChildren of a vertex, optionally restricted to a marginal genealogy. If you know in advance that v has a single child, use ̀̀child instead.\n\nThe following rules are used to decide if an edge e is ancestral:\n\nIf ωs is a number, the ancestral interval of e must cover ωs.\nIf ωs is an Ω or a set of Ωs, the intersection of the ancestral interval of e with ωs must be non-empty.\n\ndanger: Danger\nReturn a reference to the underlying adjacency lists. No touchy!\n\nSee also dad, dads, sibling, siblings, descendants and ancestors.\n\nMethods\n\nchildren(arg, v, ωs)\nchildren(arg, v, ωs)\nchildren(arg, v, ωs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:123.\n\nchildren(genealogy, v)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:740.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.ancestors","page":"AbstractGenealogy","title":"Moonshine.ancestors","text":"ancestors(genealogy, v[, ωs])\nancestors(genealogy, v[, ωs], buf_ptr)\n\nAncestors of a vertex, optionally restricted to a marginal genealogy.\n\nA pointer to some kind of buffer (an array for instance) can be provided to avoid allocation. In that case, an UnsafeArray wrapped around it will be returned.\n\nThe following rules are used to decide if an edge e is ancestral:\n\nIf ωs is a number, the ancestral interval of e must cover ωs.\nIf ωs is an Ω or a set of Ωs, the intersection of the ancestral interval of e with ωs must be non-empty.\n\nSee also child, dad, children, dads, sibling, siblings and descendants.\n\nMethods\n\nancestors(genealogy, v)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:827.\n\nancestors(genealogy, v, ω)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:860.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.descendants","page":"AbstractGenealogy","title":"Moonshine.descendants","text":"descendants(genealogy, v[, ωs])\ndescendants(genealogy, v[, ωs], buf_ptr)\n\nDescendants of a vertex, optionally restricted to a marginal genealogy.\n\nA pointer to some kind of buffer (an array for instance) can be provided to avoid allocation. In that case, an UnsafeArray wrapped around it will be returned.\n\nThe following rules are used to decide if an edge e is ancestral:\n\nIf ωs is a number, the ancestral interval of e must cover ωs.\nIf ωs is an Ω or a set of Ωs, the intersection of the ancestral interval of e with ωs must be non-empty.\n\nSee also child, dad, children, dads, sibling, siblings and ancestors.\n\nMethods\n\ndescendants(genealogy, v)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:827.\n\ndescendants(genealogy, v, ω)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:860.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.siblings!","page":"AbstractGenealogy","title":"Moonshine.siblings!","text":"siblings!(x, genealogy, v[, u], args)\n\nSiblings of a vertex, that is the other vertices in the genealogy that share at least one parent, optionally restricted to a marginal genealogy.\n\nIf you know in advance that v has a single sibling, you can use sibling instead.\n\nAs a convenience, siblings! returns an UnsafeArray wrapping pointer x.\n\nSee also child, dad, children, dads, descendants and ancestors.\n\nMethods\n\nsiblings!(x, genealogy, v, u, ancargs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:896.\n\nsiblings!(x, genealogy, v, ancargs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:908.\n\nArguments\n\nx: pointer to preallocated memory\ngenealogy: a genealogy\nv: vertex for which siblings should be computed\nu: parent with respect to which siblings should be computed\nargs: arguments for dads/children calls\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.siblings","page":"AbstractGenealogy","title":"Moonshine.siblings","text":"siblings(genealogy, v[, u], args)\n\nThis is the allocating version of siblings!.\n\nNote that siblings! is way more efficient than its allocating counterpart. It should be used in any performance sensitive code. siblings is mainly intended for interactive use and quick-and-dirty testing.\n\nMethods\n\nsiblings(genealogy, v, u, ancargs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:943.\n\nsiblings(genealogy, v, ancargs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:949.\n\nArguments\n\ngenealogy: a genealogy\nv: vertex for which siblings should be computed\nu: parent with respect to which siblings should be computed\nargs: arguments for dads/children calls\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.sibling","page":"AbstractGenealogy","title":"Moonshine.sibling","text":"sibling(genealogy, v[, u], args)\n\nSibling of a vertex, that is the other vertex in the genealogy that have the same parent. It only makes sense to use this method if you know v has a single sibling. Otherwise use siblings!.\n\nSee also child, dad, children, dads, descendants and ancestors.\n\nMethods\n\nsibling(genealogy, v, args)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:977.\n\nsibling(genealogy, v, u, args)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:987.\n\nArguments\n\ngenealogy: a genealogy\nv: vertex for which siblings should be computed\nu: parent with respect to which siblings should be computed\nargs: arguments for dads/children calls\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.ancestral_mask","page":"AbstractGenealogy","title":"Moonshine.ancestral_mask","text":"ancestral_mask(reference, x; ωs_buf = Set{Ω}())\n\nMask non ancestral positions to 0. If wipe = true, all markers in η will be initialized to 0.\n\nMethods\n\nancestral_mask(arg, x)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:224.\n\nancestral_mask(genealogy, x)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:397.\n\nancestral_mask(sample, x)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:326.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.ancestral_mask!","page":"AbstractGenealogy","title":"Moonshine.ancestral_mask!","text":"ancestral_mask!(η, reference, x; ωs_buf = Set{Ω}(), wipe = true)\n\nMask non ancestral positions to 0. If wipe = true, all markers in η will be initialized to 0.\n\nMethods\n\nancestral_mask!(η, arg, e; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:206.\n\nancestral_mask!(h, arg, v; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Arg/Arg.jl:209.\n\nancestral_mask!(η, genealogy, x; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:413.\n\nancestral_mask!(v, sample, ω; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:300.\n\nancestral_mask!(η, sample, ω; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:310.\n\nancestral_mask!(η, sample, ωs; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:316.\n\nancestral_mask!(η, sample, pos; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:329.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.tmrca","page":"AbstractGenealogy","title":"Moonshine.tmrca","text":"tmrca(genealogy[, vs])\n\nTime to the most recent common ancestor (MRCA) of (a subset of) vertices.\n\nMethods\n\ntmrca(genealogy)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:647.\n\ntmrca(genealogy, vs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Genealogy.jl:654.\n\ntmrca(arg, vs, ωs)\ntmrca(tree, vs, ωs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/genealogy_common.jl:103.\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Plotting-2","page":"AbstractGenealogy","title":"Plotting","text":"","category":"section"},{"location":"reference/AbstractGenealogy/#Moonshine.plot_genealogy","page":"AbstractGenealogy","title":"Moonshine.plot_genealogy","text":"plot_genealogy(genealogy[, ω]; kwargs...)\n\nPlot a genealogy.\n\nOnly edges and vertices ancestral for ω are plotted.\n\nImplemented as an extension to Moonshine.jl. To use this method, you have to import GraphMakie (and a Makie backend).\n\nSee also plot_layout.\n\nArguments\n\nwild_color (:blue): color of wild vertices, that is those having only wild markers in ω.\nderived_color (:red): color of derived (non-wild) vertices\narrow_show (false): whether or not to draw arrows\nedge_color (:gray): color of edges\nedge_width (3): width of edges\nlayout (plot_layout(genealogy)): layout function\nattributes...: attributes passed directly to GraphMakie.graphplot\n\n\n\n\n\n","category":"function"},{"location":"reference/AbstractGenealogy/#Moonshine.plot_latitudes","page":"AbstractGenealogy","title":"Moonshine.plot_latitudes","text":"plot_latitudes(genealogy; kwargs...)\n\n\nUnicode histogram of a genealogy's latitudes. Additional keywords arguments are passed directly to UnicodePlots.histogram.\n\nSee also latitudes, latitude\n\n\n\n\n\n","category":"function"},{"location":"quickstart/#Quick-Start","page":"QuickStart","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Pages = [\"quickstart.md\"]\nDepth = 2:2","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"The aim of this page is to present the package's main functionalities and guide you in inferring your first ancestral recombination graph. Moonshine allows you to do things like implement your own exotic model of ancestry and even crazy stuff like analyzing ARGs as linear operators; tutorials on those more advanced topics will follow soon.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"As of writing these lines, Julia's dominance in the field of molecular biology has not yet been achieved. We understand that many users might have little to no experience with it. This guide is written with that in mind. The aim is for an average Python user to have a satisfactory graph inference experience after what we expect to be a short and somewhat enjoyable read. In particular, short explanations of differences between Julia and more mainstream languages are given when relevant: keep your eyes peeled for Julia👶 admonitions. On that matter, the official documentation provides short and to the point descriptions of noteworthy departures from Python, R, C/C++, MATLAB and Common Lisp.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Feedback, especially from first-time users, is appreciated","category":"page"},{"location":"quickstart/#Storing-Haplotypes:-the-[Sample](@ref)-Type","page":"QuickStart","title":"Storing Haplotypes: the Sample Type","text":"","category":"section"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"note: Julia👶: Type vs Class\n{tl;dr} Types are classes (in the OOP sense)In Julia, the concept of type is roughly equivalent to that of class in Python, C++ or MATLAB. Functionally, the expression \"class T\" can often be substituted for \"type T\". However, Julia's types underlie a generic function-based dispatch system and are more similar to R's S3 or Common Lisp's CLOS classes.Official documentation on types","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Since we are inferring rather than simulating ARGs, we need some way to store data about haplotypes of interest. In Moonshine, the Sample type provides this functionality. Before getting into the nitty-gritty, a few things to keep in mind about the data itself:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"only biallelic markers are supported;\nthere is currently no support for ploidy other than 1;\ndata should be phased (which is basically a consequence of the last restriction);\nthe wild (ancestral) allele should be known and encoded as 0 for every marker.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"These limitations, especially the one regarding ploidy, might change in the future.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"A neat feature of Moonshine is its ability to transparently call msprime to generate a high quality sample. This should work out of the box: if you installed Moonshine as described in the README, you should have received a pre-packaged version of msprime at the same time. You only need to:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"import Moonshine;\nimport an RNG;\ninstantiate the RNG;\nconstruct a sample.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"This can be done interactively via the Julia REPL:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"using Moonshine\nusing Random: Xoshiro\nrng = Xoshiro(42)\ns = Sample(rng, 10, 1e-8, 1e-8, 1e4, 1e6)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"The first line imports the Moonshine module and exposes its exported symbols. The second line imports and exposes the Xoshiro symbol from the Random module. The third line instantiates the Xoshiro type, creating an RNG seeded at 42. As you might have guessed, the instance is stored in a variable called rng. The last line creates the sample, calling msprime.sim_ancestry under the hood. The meaning of each positional argument is detailed in Sample's documentation.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"note: Julia👶: Standard Library\nRandom is part of Julia's standard library, so you do not have to explicitly install it (although you still have to import it and its symbols). A complete list of the standard library’s modules is available in the Official documentation, section \"Standard Library\".","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"If you have a decent terminal with good Unicode support, you should get an output similar to the one above. Otherwise, do yourself a favor and download a modern terminal emulator (list here).","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"If you're new to Julia, yes, we can be fast and look good. Sequences are displayed as one-dimensional heatmaps for convenience. You can get a slightly more detailed output using the plot_sequence method:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"plot_sequence(s[1])","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"The result is a little bit distorted (at least on my browser) but should look alright on your terminal. Notice how we extracted the first (arrays start at 1 over here) sequence? If you have a look at Sample's documentation, you will notice two things. First, the Sample type is a subtype of abstract type AbstractVector{Sequence} (the <: AbstractVector{Sequence} bit). This is similar to inheritance: any argument of type AbstractVector{Sequence} (or a supertype thereof, for that matter) is satisfiable by a Sample in a method call. Second, Sample implements two interfaces: the array interface and the iteration interface. This means we can basically treat them as arrays (like we did) and as iterables (using a for loop or a higher order function such as Base.argmax).","category":"page"},{"location":"quickstart/#Coalescent-Trees:-the-[Tree](@ref)-type","page":"QuickStart","title":"Coalescent Trees: the Tree type","text":"","category":"section"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Now that we have some data, it's time to build our first coalescent tree. A quick look at Tree's documentation reveals that it can be constructed from a sample:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"tree = Tree(s)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Conveniently, the REPL displays that tree is a coalescent tree with 10 leaves (corresponding to the 10 sequences in s) and 563 markers. The tMRCA, which is the latitude of the sample's \"grand\" MRCA, is 0. This is because there is a distinction between constructing a tree, which merely means instantiating Tree, and building it. The latter stands for sampling a topology (in a graph-theoretical sense, vertices & edges) and latitudes (coalescence times). Right now, the topology of tree is that of an edgeless graph with 10 isolated vertices. Let's do something about it. We build a tree with the build! method:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"rng_orig = copy(rng)\nbuild!(rng, tree)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"note: Julia👶: Bang!\nNotice the '!' character at the end of build!? This is called a \"bang\" so that the method would be pronounced \"build-bang\". An informal but widely adopted naming convention in Julia (and some other languages) is to end functions that mutate at least one argument with a bang. Technically, build! mutates rng, but we usually don't bother for such uses of random number generators. tree, however, is mutated, hence the bang! Conversely, you can generally assume bang-less functions not to mutate anything.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"I added the first line for repeatability; it will come in handy later. We can ignore it for now. Before explaining the building process any further, we take a quick break to talk about visualization. First, a neat little histogram of tree's latitudes can be obtained via the plot_latitudes method:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"plot_latitudes(tree)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"While it's not going to win any beauty contest soon, it's quick, easy, and since it's plain text, you can literally do a copy & paste and text it to someone special. That's for the latitudes, but what about the topology? You can plot that too, provided you installed two packages:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"GraphMakie;\nGLMakie (or any other Makie backend).","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"You can then plot tree via the plot_genealogy method:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"julia> using GraphMakie\n\njulia> using GLMakie\n\njulia> plot_genealogy(tree)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"After some time, you should obtain the following plot: (Image: ) This is all good and well, but you might wonder about the distribution of tree. tree is a coalescent tree in the graph-theoretical sense, meaning that it is a full binary tree. Since we are working conditional on a sample of haplotypes however, it does not follow the \"classical\" distribution inherited from Kingman's seminal paper. Moonshine's default distribution for coalescent trees is related to three things:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"the mutation rate;\nthe Hamming distance between sequences;\na bias parameter that favors coalescence between similar sequences.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Mutation events induce a distance between haplotypes, namely the number of events necessary to turn one into another. For sequences of binary markers, this is simply the Hamming distance. Moonshine assumes that mutation events are distributed according to a Poisson process with user-defined mutation rate and sample coalescence events accordingly. That being said, we might want to tweak the sampling distribution in certain scenarios. One simple example is that of the infinite site model in which each site is allowed to mutate at most once. This can be implemented via a degenerate Poisson process, so to speak, where the distance between two haplotypes is 0 if they are identical and infinite otherwise. In order to enable the implementation of such models, distances can be biased via a user-defined parameter. A bias value of b will add bd to a distance d.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Enough talking, let's put that into practice. The mutation rate is defined by the use as described in the previous section). Bias can be tuned via the bias0 keyword argument of build!. Valid values go from 0 (no bias, default value) to Inf (strong bias). Let's build a tree similar to the previous one but with infinite bias:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"rng = copy(rng_orig)\ntree0 = Tree(s)\nbuild!(rng, tree0, bias0 = Inf)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"plot_latitudes(tree0)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"julia> plot_genealogy(tree0)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"(Image: ) Notice the difference from the previous plot, even though we used the same sample and RNG. Alright, one last tree example. A common requirement for spatial ARG inference algorithms is building a tree consistent with the leftmost marker. To accomplish that, we need to abandon Hamming distance, since it considers all markers. Moonshine ships with the LeftM \"distance\", which is nothing more than the discrete metric on the leftmost marker. First, let's have a look at the situation on tree. We can color vertices according to the status of their leftmost marker as follows:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"julia> plot_genealogy(tree, Ω(positions(tree)[1:2]...))","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"(Image: )","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"note: Julia👶: Splat...\nIf you've never encountered it before in another language, the ellipsis (\"...\") is an operator that performs an operation known as \"splatting\". It allows using elements of a collection as positional arguments in a function call, rather than passing the collection itself as a single argument.For more details, see ... in the official documentation.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"In the method call above, Ω stands for a right semi-open interval: Ω(a, b) is Moonshine's way of representing the interval a b). As you might have guessed, positions(tree)[1:2] returns the positions of the first two markers of tree. These are then splatted into Ω so that Ω(positions(tree)[1:2]...) represents p_1 p_2) where p_k is the position of marker k. Passing this interval as the second argument to plot_genealogy tells it to only consider edges, vertices and markers that are ancestral to it. In particular, vertices are colored according to the status of the markers included in the interval (which is only the first marker in our example): a vertex is red if all markers are derived, blue otherwise. This means there are three mutation edges with respect to the first marker in tree: 17-1, 14-13 and 12-11. Let's build tree again, this time using LeftM and an infinite bias, and see what happens:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"tree_left = Tree(s)\nbuild!(copy(rng_orig), tree_left, Dist = LeftM(), bias0 = Inf)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"julia> plot_genealogy(tree_left, Ω(positions(tree_left)[1:2]...))","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"(Image: ) As expected, the leftmost marker mutates only once.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Before moving on to ARGs, I have to tell you about another handy constructor for Tree. Since multiple single-use samples are pretty common, it can be somewhat cumbersome to explicitly construct them every time we want to build a tree. To make our lives a little easier, there is a constructor that transparently calls Sample's random constructor and constructs a new tree from the result. Long story short, we could have built tree more succinctly:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"rng = Xoshiro(42)\ntree_lazy = Tree(rng, 10, 1e-8, 1e-8, 1e4, 1e6)\nbuild!(rng, tree_lazy)","category":"page"},{"location":"quickstart/#Ancestral-Recombination-Graphs:-the-[Arg](@ref)-Type","page":"QuickStart","title":"Ancestral Recombination Graphs: the Arg Type","text":"","category":"section"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Instances of Tree are built on top of instances of Sample. The design behind this is conceptual: coalescent trees contain all the information present in the associated sample and more, namely a topology and coalescence times. Of course, as far as we are concerned, this is merely a convenient fiction since we have no direct knowledge of the tree: we literally inferred it from the sample! But don't think about that too much. After all, we are mathematicians (of sorts), so let's assume our trees are actual ancestries. We can further improve on them by sampling recombination events. Hence, it should come as no surprise that instances of Arg, Moonshine's tailor-made type to represent ARGs, are built on top of instances of Tree. You should be equally unsurprised when you learn that they can be constructed in much the same way as Tree were","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"arg_tree = Arg(tree)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"and you should literally fall asleep from boredom when I tell you how to build them:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"rng = Xoshiro(42)\nbuild!(rng, arg_tree)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Just to make sure your lack of surprise is total, let me show you how to plot its vertices' latitudes:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"plot_latitudes(arg_tree)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"I won't plot_genealogy it, though, since, as you might have noticed, this is quite a demanding process even for a tree with 19 vertices.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Moonshine's ARG building algorithm is of the spatial (as opposed to temporal) kind: it iteratively adds recombination and recoalescence events to a tree until every marker in the initial sample mutates at most once in its history. The resulting graph is said to be consistent with the sample. As you have just witnessed, unlike similar algorithms, the initial tree is not required to be consistent with the leftmost marker. Moonshine really doesn't care what you throw at it, as long as it is a valid ancestral recombination graph (or coalescent tree, of which they are special cases). This opens the door to things like MCMC sampling, which might be implemented in the future. For now, let’s illustrate Moonshine’s functionalities further with something more substantial:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"rng = Xoshiro(42)\n\n@time begin\n    arg = Arg(rng, 3000, 1e-8, 1e-8, 1e4, 1e6)\n    build!(rng, arg)\nend\n\nplot_latitudes(arg)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"note: Julia👶: Macros\nJulia has a very rich macro system, similar to Common Lisp's. Macros can be told appart from from functions by the '@' prefix in their names. If you are not familiar with Lisp, just keep in mind that their arguments do not need to be valid Julia expressions.Official documentation on macros","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"note: Julia👶: begin...end\nDenote a block of code. It was used above because the method of the Base.@time macro we are interested in only accepts a single argument.See begin in the official documentation.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"A couple of things to unpack here. First, notice the usage of the @time macro. In addition to the total execution time, it also informs us about the number of memory allocations performed, the total memory usage (which is greater than the peak memory usage), and the percentage of execution time dedicated to garbage collection. The next couple of lines are similar to the ones displayed for trees and tell us about the number of haplotypes (\"leaves\") and markers associated with arg. We can easily plot the distribution of breakpoints (recombination positions):","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"plot_breakpoints(arg)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Another interesting and easily plottable feature are tMRCAs:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"plot_tmrcas(arg, npoints = 300, noprogress = true)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"As you may have noticed, computing tMRCAs is a slow process. The npoints argument allows trading precision for speed, as it limits computation to a grid of approximately 200 points. By default, the tMRCA is evaluated at every breakpoint, which is very slow. You may also have noticed that computation is done concurrently; this helps speed things up a little. Finally, a progress meter should be displayed. I disabled it via the noprogress = true parameter because my output is static, but there is probably no reason for you to do so.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"note: Julia👶: Multi-Threading\nJulia is built with multi-threading in mind. For instance, you can get the number of active threads via Base.Threads.nthreads. To set the number of threads, just invoke Julia with the -t N switch, where N is the desired number.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"The algorithm used to build arg is exact in the sense that each new event is sampled conditional on the entire graph, or more precisely the subgraph that is already built at the time of sampling. Of course, since we are also working conditional on a set of haplotypes, we have to impose additional restrictions on the distributions compared to samplers such as msprime. Moonshine is exact in the sense that there is no SMC-type trickery involved. That being said, we emphatically have nothing against Markovian approximations of recombination. In fact, Moonshine is able to perform aformentioned trickery. build! accepts a keyword argument named winwidth which, as its name suggests, controls the window of positions considered when sampling an event. It is infinite by default, leading to \"exact\" sampling. Setting it to 0 leads to \"approximate\" SMC-type sampling with potentially significant speed gains. Let's do a quick comparison.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"rng = Xoshiro(42)\ns = Sample(rng, 1000, 1e-8, 1e-8, 1e4, 1e7);\n\ntree_exact = Tree(s)\nbuild!(rng, tree_exact)\ntree_smc = deepcopy(tree_exact)\n\narg_exact = Arg(tree_exact)\narg_smc = Arg(tree_smc)\n\n@time build!(rng, arg_exact, noprogress = true)\n@time build!(rng, arg_smc, winwidth = 0, noprogress = true)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"As you can see, there are significant gains. Memory usage is a little higher for approximate sampling due to the increased number of recombination events, ultimately leading to, well, more stuff to store in memory. We can actually verify that:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"nrecombinations(arg_exact)\nnrecombinations(arg_smc)","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Of course, window widths between 0 and infty lead to \"proportional\" levels of approximation.","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"Tree, Arg and any properly designed subtype of AbstractGenealogy also implement the Graphs.AbstractGraph interface. This ensures complete compatibility with Graphs.jl and, by extension, Julia's whole graph-theoretical ecosystem. As an example, let's pretend we are very interested in computing maximum flow between the first two vertices of arg. No need to resort to complex code: this can be done in a couple of lines by invoking GraphsFlows.maximum_flow from GraphFlows.jl:","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"using Graphs, GraphsFlows, SparseArrays\ncapmat = spzeros(Float64, nv(arg), nv(arg)); # 0-initialized sparse matrix\nfor e ∈ edges(arg) # fill capacity matrix\n    ibl = (inv ∘ branchlength)(arg, e) # capacity = 1/length of branch\n    capmat[src(e), dst(e)] = capmat[dst(e), src(e)] = ibl\nend\nflow, flowmat = maximum_flow(arg, 1, 2, capmat)\ndroptol!(flowmat, (eps ∘ eltype)(flowmat)) # optional cleanup","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"note: Julia👶: function ∘ composition\n{tl;dr} (f ∘ g)(x...) = f(g(x...))∘ is obtained in the REPL via LaTeX-type syntax and tab completion: just type \\circ<TAB>. Learn all about it in the official documentation","category":"page"},{"location":"quickstart/","page":"QuickStart","title":"QuickStart","text":"In addition, Moonshine implements a variety of specialized, coalescent theory-related methods. These are described in the AbstractGenealogy section. Methods specific to coalescent trees and ancestral recombination graphs are also available and documented in Tree & ARG. The API is not fully documented yet, but will be improved shortly. That's about it for now. Go on and have fun coalescing!","category":"page"},{"location":"reference/utilities/#Utilities","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"reference/utilities/#Moonshine.:⊙","page":"Utilities","title":"Moonshine.:⊙","text":"⊙(A, B)\n\n\nKhatri-Rao (column-wise Kronecker) product.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/Sample/#Sample","page":"Sample","title":"Sample","text":"","category":"section"},{"location":"reference/Sample/#Moonshine.Sample","page":"Sample","title":"Moonshine.Sample","text":"struct Sample <: AbstractVector{Sequence}\n\nContain a sample of haplotypes and informations about them.\n\nImplements the iteration interface and the array interface.\n\nFields\n\nH::Vector{Sequence}: Vector of haplotypes\nμ::Float64: Unscaled (per-locus) mutation rate\nρ::Float64: Unscaled (per-locus) recombination rate\nNe::Float64: Effective population size\nsequence_length::Float64: Sequence length\npositions::Vector{Float64}: Marker's positions\ncoefs::Tuple{Float64, Float64}: Coefficients for positions' line\n\nConstructors\n\ninfo: Info\nRandom constructor sample sequences via msprime using a binary mutation model.\n\nSample(H, μ, ρ, Ne, sequence_length, positions, coefs)\nSample(H, μ, ρ, Ne, sequence_length, positions, coefs)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:33.\n\nSample(H; μ, ρ, Ne, sequence_length, positions)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:49.\n\nSample(ts)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:64.\n\nSample(rng, n, μ, ρ, Ne, sequence_length)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:102.\n\nwhere:\n\nn: number of sequences\nrng: random number generator\nts: Tree Sequence\n\n\n\n\n\n","category":"type"},{"location":"reference/Sample/#Moonshine.mask!","page":"Sample","title":"Moonshine.mask!","text":"mask!(h, sample, idx; wipe = true)\n\nConstruct a mask for a range of markers.\n\nIf wipe = true, h is wiped beforehand.\n\nSee also wipe!.\n\nMethods\n\nmask!(h, sample, idx; wipe)\n\ndefined at /home/runner/work/Moonshine.jl/Moonshine.jl/src/Sample.jl:251.\n\n–Internal–\n\n\n\n\n\n","category":"function"},{"location":"reference/Sample/#Moonshine.mut_rate","page":"Sample","title":"Moonshine.mut_rate","text":"mut_rate(sample, scaled = true)\n\n(Scaled) mutation rate.\n\n\n\n\n\n","category":"function"},{"location":"reference/Sample/#Moonshine.rec_rate","page":"Sample","title":"Moonshine.rec_rate","text":"rec_rate(sample, scaled = true)\n\n(Scaled) recombination rate.\n\n\n\n\n\n","category":"function"},{"location":"#Moonshine.jl-Documentation","page":"Home","title":"Moonshine.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nUnder active development, breaking changes are likely, and documentation is a work in progress.Expect nothing. Live frugally on surprise. Report any issue to the project's Github repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Moonshine.jl is a Julia framework for coalescent modelling oriented towards ancestral recombination graph (ARG) inference. It provides the AbstractGenealogy type which leverages Graph.jl for convenient implementation of graph-theoretical phylogenetic models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: QuickStart\nFirst things first, you are probably looking for the QuickStart page.Read it. It's awesome.","category":"page"},{"location":"#Peer-Review","page":"Home","title":"Peer Review","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As of today, Moonshine.jl has not undergone any formal peer review process, but that should happen soon as a paper is currently in preparation. I'll keep this section updated for those of you who value scientific rigor.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On that matter, note that this package places a strong emphasis on reproducibility through design choices that will be documented soon. Much of this is made possible by Melissa O'Neil's PCG family of random number generator. Her website and, in particular, her blog, are definitely worth reading if you care about random number generation, especially when done concurrently.","category":"page"},{"location":"#Inference","page":"Home","title":"Inference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Out of the box, types representing coalescent trees and ancestral recombination graphs are provided: see Tree and Arg respectively. Efficient inference algorithms are implemented: see build!.","category":"page"},{"location":"#Package-Ecology","page":"Home","title":"Package Ecology","text":"","category":"section"},{"location":"#msprime","page":"Home","title":"msprime","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Moonshine can infer trees and ARG's directly from TreeSequence objects. For convenience, it is also possible to generate a sample of haplotypes directly from msprime with a single line of Julia code. Both these functionalities are documented in type Sample's documentation.","category":"page"},{"location":"#Conventions","page":"Home","title":"Conventions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation implements the following conventions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"constructors are documented with types;\nnon-exported symbols are documented and marked with –Internal–.","category":"page"}]
}
